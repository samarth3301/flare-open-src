"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buttonPages = void 0;
const discord_js_1 = require("discord.js");
const error_1 = require("./error");
const misc_1 = require("./misc");
// ------------------------------
// ------ F U N C T I O N -------
// ------------------------------
/**
 * ## buttonPages
 * ### An *powerful yet customizable* **Embed Paginator**
 *
 * @async
 * @param {ExtendedMessage|ExtendedInteraction} msgOrint [`ExtendedMessage`](https://simplyd.js.org/docs/typedef/extendedmessage) | [`ExtendedInteraction`](https://simplyd.js.org/docs/typedef/extendedinteraction)
 * @param {pagesOptions} options [`pagesOptions`](https://simplyd.js.org/docs/general/buttonpages#pagesoptions)
 * @returns {Promise<void>} `void`
 *
 * ---
 *
 * @link [`Documentation`](https://simplyd.js.org/docs/general/buttonPages)
 * @example simplydjs.buttonPages(interaction, [embed1, embed2] )
 */
async function buttonPages(msgOrint, options = { strict: false }) {
    return new Promise(async () => {
        try {
            options.skips ??= true;
            options.delete ??= true;
            options.dynamic ??= false;
            options.count ??= false;
            options.disable ||= 'Label';
            if (!options.embeds)
                if (options.strict)
                    throw new error_1.SimplyError({
                        function: 'buttonPages',
                        title: 'Provide an array for the pages option',
                        tip: `Expected an array of MessageEmbed. Received ${options.embeds || 'undefined'}`
                    });
                else
                    console.log(`SimplyError - buttonPages | Error:  Provide an array for the pages option. Expected an array of MessageEmbed. Received ${options.embeds || 'undefined'}`);
            let comps;
            if (options?.rows) {
                if (!Array.isArray(options.rows)) {
                    if (options?.strict)
                        throw new error_1.SimplyError({
                            function: 'buttonPages',
                            title: `Provide an array for the rows`,
                            tip: `Expected an array of MessageActionRows. Received ${options?.rows || 'undefined'}`
                        });
                    else
                        console.log(`SimplyError - buttonPages | Provide an array for the rows\n\n` +
                            `Expected an array of MessageActionRows. Received ${options?.rows || 'undefined'}`);
                }
                comps = options?.rows;
            }
            else {
                comps = [];
            }
            const buttonStyles = {
                first: {
                    style: options?.buttons?.first?.style || discord_js_1.ButtonStyle.Primary,
                    emoji: options?.buttons?.first?.emoji || '‚è™',
                    label: options?.buttons?.first?.label || 'First'
                },
                next: {
                    style: options?.buttons?.next?.style || discord_js_1.ButtonStyle.Success,
                    emoji: options?.buttons?.next?.emoji || '‚ñ∂Ô∏è',
                    label: options?.buttons?.next?.label || 'Next'
                },
                back: {
                    style: options?.buttons?.back?.style || discord_js_1.ButtonStyle.Success,
                    emoji: options?.buttons?.back?.emoji || '‚óÄÔ∏è',
                    label: options?.buttons?.back?.label || 'Back'
                },
                last: {
                    style: options?.buttons?.last?.style || discord_js_1.ButtonStyle.Primary,
                    emoji: options?.buttons?.last?.emoji || '‚è©',
                    label: options?.buttons?.last?.label || 'Last'
                },
                delete: {
                    style: options?.buttons?.delete?.style || discord_js_1.ButtonStyle.Danger,
                    emoji: options?.buttons?.delete?.emoji || 'üóë',
                    label: options?.buttons?.delete?.label || 'Delete'
                }
            };
            if (buttonStyles.first?.style)
                buttonStyles.first.style = (0, misc_1.toButtonStyle)(buttonStyles.first?.style);
            if (buttonStyles.next?.style)
                buttonStyles.next.style = (0, misc_1.toButtonStyle)(buttonStyles?.next?.style);
            if (buttonStyles.back?.style)
                buttonStyles.back.style = (0, misc_1.toButtonStyle)(buttonStyles.back?.style);
            if (buttonStyles.last?.style)
                buttonStyles.last.style = (0, misc_1.toButtonStyle)(buttonStyles.last?.style);
            if (buttonStyles.delete?.style)
                buttonStyles.delete.style = (0, misc_1.toButtonStyle)(buttonStyles.delete?.style);
            //Defining all buttons
            const first = new discord_js_1.ButtonBuilder()
                .setCustomId('first_embed')
                .setStyle(buttonStyles.first?.style || discord_js_1.ButtonStyle.Primary);
            if (options?.disable === 'Label' || options?.disable === 'None')
                first.setEmoji(buttonStyles.first?.emoji || '‚è™');
            else if (options?.disable === 'Emoji' || options?.disable === 'None')
                first.setLabel(buttonStyles.first?.label || 'First');
            const forward = new discord_js_1.ButtonBuilder()
                .setCustomId('forward_button_embed')
                .setStyle(buttonStyles.next?.style || discord_js_1.ButtonStyle.Success);
            if (options?.disable === 'Label' || options?.disable === 'None')
                forward.setEmoji(buttonStyles?.next?.emoji || '‚ñ∂Ô∏è');
            else if (options?.disable === 'Emoji' || options?.disable === 'None')
                forward.setLabel(buttonStyles?.next?.label || 'Next');
            const back = new discord_js_1.ButtonBuilder()
                .setCustomId('back_button_embed')
                .setStyle(buttonStyles?.back?.style || discord_js_1.ButtonStyle.Success);
            if (options?.disable === 'Label' || options?.disable === 'None')
                back.setEmoji(buttonStyles?.back?.emoji || '‚óÄÔ∏è');
            else if (options?.disable === 'Emoji' || options?.disable === 'None')
                back.setLabel(buttonStyles?.back?.label || 'Back');
            const last = new discord_js_1.ButtonBuilder()
                .setCustomId('last_embed')
                .setStyle(buttonStyles.last?.style || discord_js_1.ButtonStyle.Primary);
            if (options?.disable === 'Label' || options?.disable === 'None')
                last.setEmoji(buttonStyles.last?.emoji || '‚è©');
            else if (options?.disable === 'Emoji' || options?.disable === 'None')
                last.setLabel(buttonStyles.last?.label || 'Last');
            if (options?.dynamic) {
                first.setDisabled(true);
                back.setDisabled(true);
            }
            const deleteButton = new discord_js_1.ButtonBuilder()
                .setCustomId('delete_embed')
                .setStyle(buttonStyles?.delete?.style || discord_js_1.ButtonStyle.Danger);
            if (options?.disable === 'Label' || options?.disable === 'None')
                deleteButton.setEmoji(buttonStyles?.delete?.emoji || 'üóë');
            else if (options?.disable === 'Emoji' || options?.disable === 'None')
                deleteButton.setLabel(buttonStyles?.delete?.label || 'Delete');
            let btnCollection = [];
            //Creating the MessageActionRow
            let pageMovingButtons = new discord_js_1.ActionRowBuilder();
            if (options?.skips == true) {
                if (options?.delete) {
                    btnCollection = [first, back, deleteButton, forward, last];
                }
                else {
                    btnCollection = [first, back, forward, last];
                }
            }
            else {
                if (options?.delete) {
                    btnCollection = [back, deleteButton, forward];
                }
                else {
                    btnCollection = [back, forward];
                }
            }
            pageMovingButtons.addComponents(btnCollection);
            let currentPage = 0;
            comps.push(pageMovingButtons);
            let interaction;
            if (msgOrint.commandId) {
                interaction = msgOrint;
                if (!interaction.deferred)
                    await interaction.deferReply({ fetchReply: true });
            }
            let m;
            const pages = options?.embeds;
            const extInteraction = msgOrint;
            const extMessage = msgOrint;
            if (interaction) {
                if (options?.count) {
                    await extInteraction.followUp({
                        embeds: [pages[0].setFooter({ text: `Page 1/${pages.length}` })],
                        components: comps,
                        allowedMentions: { repliedUser: false },
                        fetchReply: true
                    });
                }
                else {
                    await extInteraction.followUp({
                        embeds: [pages[0]],
                        components: comps,
                        allowedMentions: { repliedUser: false },
                        fetchReply: true
                    });
                }
                m = await extInteraction.fetchReply();
            }
            else if (!interaction) {
                if (options?.count) {
                    m = await extMessage.reply({
                        embeds: [pages[0].setFooter({ text: `Page 1/${pages.length}` })],
                        components: comps,
                        allowedMentions: { repliedUser: false }
                    });
                }
                else {
                    m = await extMessage.reply({
                        embeds: [pages[0]],
                        components: comps,
                        allowedMentions: { repliedUser: false }
                    });
                }
            }
            const filter = (m) => m.user.id === (msgOrint.user ? msgOrint.user : msgOrint.author).id;
            const collector = m.createMessageComponentCollector({
                time: options?.timeout || (0, misc_1.ms)('2m'),
                filter: filter,
                componentType: discord_js_1.ComponentType.Button
            });
            collector.on('collect', async (b) => {
                if (!b.isButton())
                    return;
                if (b.message.id !== m.id)
                    return;
                await b.deferUpdate();
                if (b.customId == 'back_button_embed') {
                    if (currentPage - 1 < 0)
                        currentPage = pages.length - 1;
                    else
                        currentPage -= 1;
                }
                else if (b.customId == 'forward_button_embed') {
                    if (currentPage + 1 == pages.length)
                        currentPage = 0;
                    else
                        currentPage += 1;
                }
                else if (b.customId == 'last_embed') {
                    currentPage = pages.length - 1;
                }
                else if (b.customId == 'first_embed') {
                    currentPage = 0;
                }
                if (options?.dynamic) {
                    if (currentPage === 0) {
                        const btn = comps[0].components[0];
                        btn.setDisabled(true);
                        if (options?.skips) {
                            const skip = comps[0].components[1];
                            skip.setDisabled(true);
                            comps[0].components[1] = skip;
                        }
                        comps[0].components[0] = btn;
                    }
                    else {
                        const btn = comps[0].components[0];
                        btn.setDisabled(false);
                        if (options?.skips) {
                            const skip = comps[0].components[1];
                            skip.setDisabled(false);
                            comps[0].components[1] = skip;
                        }
                        comps[0].components[0] = btn;
                    }
                    if (currentPage === pages.length - 1) {
                        if (options?.skips) {
                            const bt = comps[0].components[3];
                            const inde = comps[0].components[4];
                            inde.setDisabled(true);
                            bt.setDisabled(true);
                            comps[0].components[3] = bt;
                            comps[0].components[4] = inde;
                        }
                        else {
                            const bt = comps[0].components[2];
                            bt.setDisabled(true);
                            comps[0].components[2] = bt;
                        }
                    }
                    else {
                        if (options?.skips) {
                            const bt = comps[0].components[3];
                            const inde = comps[0].components[4];
                            inde.setDisabled(false);
                            bt.setDisabled(false);
                            comps[0].components[3] = bt;
                            comps[0].components[4] = inde;
                        }
                        else {
                            const bt = comps[0].components[2];
                            bt.setDisabled(false);
                            comps[0].components[2] = bt;
                        }
                    }
                }
                if (b.customId !== 'delete_embed') {
                    if (options?.count) {
                        m.edit({
                            embeds: [
                                pages[currentPage].setFooter({
                                    text: `Page: ${currentPage + 1}/${pages.length}`
                                })
                            ],
                            components: comps,
                            allowedMentions: { repliedUser: false }
                        });
                    }
                    else {
                        m.edit({
                            embeds: [pages[currentPage]],
                            components: comps,
                            allowedMentions: { repliedUser: false }
                        });
                    }
                }
                else if (b.customId === 'delete_embed') {
                    collector.stop('del');
                }
            });
            collector.on('end', async (_collected, reason) => {
                if (reason === 'del') {
                    await m.delete().catch(() => { });
                }
                else {
                    const disable = [];
                    btnCollection.forEach((a) => {
                        disable.push(a.setDisabled(true));
                    });
                    pageMovingButtons =
                        new discord_js_1.ActionRowBuilder().addComponents(disable);
                    m.edit({ components: [pageMovingButtons] });
                }
            });
        }
        catch (err) {
            if (options?.strict)
                throw new error_1.SimplyError({
                    function: 'buttonPages',
                    title: 'An Error occured when running the function ',
                    tip: err.stack
                });
            else
                console.log(`SimplyError - buttonPages | Error: ${err.stack}`);
        }
    });
}
exports.buttonPages = buttonPages;
